alias funnum R1;
alias pid R2;
alias userpage R3;
alias i R4;

if(funnum==1) then//getpcb entry
    i=0;
    while(i<16)do
       if([PROCESS_TABLE+16*i+4]==TERMINATED)then
          [PROCESS_TABLE+16*i+1]=i;
          [PROCESS_TABLE+16*i+4]=ALLOCATED;
          [PROCESS_TABLE+16*i+14]=PAGE_TABLE_BASE+20*i;
          [PROCESS_TABLE+16*i+15]=10;
          R0=i;
          return;
       endif;
      i=i+1; 
    endwhile;
    R0=-1;
     
    return;
endif;


if(funnum==2)then //free userareapage
  i=0;
  multipush(R0,R1,R2,R3,R4);
  while(i<8)do
    if([[PROCESS_TABLE +pid*16+11]*512+2*i+496]==1)then
      R1=7;//release semaphore
      R3=pid;
      R2=[[PROCESS_TABLE +pid*16+11]+2*i+496+1];
      call MOD_0;//resource manger
      endif;
       if([[PROCESS_TABLE +pid*16+11]+2*i+496]==FILE) then
            R1=4; //close
            R2=[[PROCESS_TABLE +pid*16+11]+2*i+496+1];
            call FILE_MANAGER;
        endif;
      i=i+1;
   endwhile;
  multipop(R0,R1,R2,R3,R4);
  userpage=[PROCESS_TABLE + pid* 16 + 11];
    multipush(R0,R1,R2,R3,R4);
    R1=2; //release page
    R2=userpage;
    call MOD_2; //memory manager
    multipop(R0,R1,R2,R3,R4);
    return;
endif;

if(funnum==3)then//exit process
   
    multipush(R0,R1,R2,R3,R4);
    R1=4;
    R2=pid;
    call MOD_1;
    multipop(R0,R1,R2,R3,R4);
     multipush(R0,R1,R2,R3,R4);
    R1=2; 
    R2=pid;
    call MOD_1; 
    multipop(R0,R1,R2,R3,R4);
    
    alias i R4;
    i=0;
    while(i<16) do 
      if([PROCESS_TABLE+[SYSTEM_STATUS_TABLE+1]*16+9]!=9)then
         if(([PROCESS_TABLE+i*16+4]==WAIT_PROCESS) && ([PROCESS_TABLE+i*16+5]==pid))then
               [PROCESS_TABLE + i* 16 + 4]=READY;
         endif;
         if([PROCESS_TABLE+i*16+2]==pid)then
             [PROCESS_TABLE+i*16+2]=-1;
          endif;
       endif;
       i=i+1;
     endwhile;
     [PROCESS_TABLE+[SYSTEM_STATUS_TABLE+1]*16+4]=TERMINATED;
    return;
    
endif;

if(funnum==4)then //free page table
   PTBR = PAGE_TABLE_BASE + pid*20;
    [PTBR+0]=-1; 
    [PTBR+1]="0000";
    [PTBR+2]=-1;
    [PTBR+3]="0000";
  i=0;
   while (i<8) do 
       if([PTBR+2*i+4]!=-1)then
       // release page 
                        multipush(R0,R1,R2,R3,R4);
                        R1 = 2;
                        R2 = [PTBR +2*i+4];
                        call MOD_2 ;
                        multipop(R0,R1,R2,R3,R4);

       // invalidate each pagetable entry
                        [PTBR + 2*i+4] = -1;
                        [PTBR + 2*i+5] = "0000";
                    endif;
                    i = i+1;
            
    endwhile;
    // heap and stack valid entries if found are released by release block 
    i=2;
    while(i<4) do
        if([DISK_MAP_TABLE+10*pid+i]!=-1) then
            multipush(R0,R1,R2,R3,R4);
            R1=4; //release block
            R3=pid;
            R2=[DISK_MAP_TABLE+10*pid+i];
            call MEMORY_MANAGER;
            multipop(R0,R1,R2,R3,R4);
        endif;
        i=i+1;
    endwhile;
    i=8;
    while(i<10) do
        if([DISK_MAP_TABLE+10*pid+i]!=-1) then
            multipush(R0,R1,R2,R3,R4);
            R1=4; //release block
            R3=pid;
            R2=[DISK_MAP_TABLE+10*pid+i];
            call MEMORY_MANAGER;
            multipop(R0,R1,R2,R3,R4);
        endif;
        i=i+1;
    endwhile;
    i=0;
    while(i<10) do //free disk map table
        [DISK_MAP_TABLE+10*pid+i]=-1;
        i=i+1;
    endwhile;
     return;
endif;
